using System;
using System.Collections.Generic;
using System.Linq;
using Meta.Numerics.Matrices;
using Meta.Numerics.Statistics;

namespace CostSystemSim {
    /// <summary>
    /// This class encapsulates a firm. It contains the firm's production technology,
    /// output market parameters, and pointers to one or more cost systems based on this
    /// firm.
    /// </summary>
    public class Firm {

        #region Fields

        /// <summary>
        /// Element ij of the matrix is the number of units of resource i (row) 
        /// consumed by product j (column).
        /// Dimensions: ip.RCP x ip.CO.
        /// </summary>
        private RectangularMatrix res_cons_pat;

        /// <summary>
        /// Percentage of each resource consumed by each product. Each row will sum to 1.0.
        /// Dimensions: ip.RCP x ip.CO.
        /// </summary>
        private RectangularMatrix res_cons_pat_prct;

        /// <summary>
        /// Correlation matrix showing correlations of resource consumptions.
        /// Dimensions: ip.RCP x ip.RCP.
        /// </summary>
        private SymmetricMatrix pearsoncorr;

        /// <summary>
        /// The value of DISP2.
        /// </summary>
        private readonly double g;

        /// <summary>
        /// The density (sparsity) of the RES_CONS_PAT matrix.
        /// </summary>
        private readonly double d;

        /// <summary>
        /// A vector of maximum production quantities of the products (cost objects).
        /// Dimensions: ip.CO x 1
        /// </summary>
        private ColumnVector mxq;

        /// <summary>
        /// Vector of unit resource costs (price the firm pays per unit of each resource).
        /// Dimensions: 1 x ip.RCP
        /// </summary>
        private RowVector rcu;

        /// <summary>
        /// Vector of selling prices of products (cost objects).
        /// Dimensions: 1 x ip.CO
        /// </summary>
        private RowVector sp;

        /// <summary>
        /// Randomly generated vector of resource costs (RCC) used to create this firm.
        /// </summary>
        private RowVector initial_rcc;

        /// <summary>
        /// The ranking of resources, by size, in the initial RCC vector.
        /// </summary>
        private int[] initial_rank;

        /// <summary>
        /// A list of cost systems based on this firm object.
        /// </summary>
        public List<CostSys> costSystems = new List<CostSys>();

        /// <summary>
        /// The profit generated by producing the profit-maximizing product mix.
        /// </summary>
        private double profitt0;

        #endregion

        #region Constructor and helper functions

        /// <summary>
        /// Randomly generates a firm object (production technology and output market parameters).
        /// </summary>
        /// <param name="ip">A pointer to the collection of input parameters.</param>
        /// <param name="FirmID">Unique identifier for this firm (run number)</param>
        public Firm( InputParameters ip, int FirmID ) 
        {
            // Choose random values for DISP2 (the top DISP1 resources
            // account for DISP2 percent of total resource costs), and
            // density (sparsity) of resource consumption pattern matrix
            this.g = GenRandNumbers.GenUniformDbl(ip.DISP2_MIN, ip.DISP2_MAX);
            this.d = GenRandNumbers.GenUniformDbl(ip.DNS_MIN, ip.DNS_MAX);
            
            // Generate the true product margins and the true, optimal
            // decision vector. Keep generating new margins until there
            // is at least one product in the optimal mix.
            RowVector MAR, DECT0;
            do {
                MAR = this.GenMargins(ip);
                DECT0 = MAR.Map(x => (x < 1.0) ? 0.0 : 1.0);
            } while (DECT0.TrueForAll(x => x == 0.0));

            // Generate vector of maximum production quantities
            this.mxq = this.GenMXQ(ip);
            // And associated vector of optimal production quantities
            ColumnVector QT = mxq.ewMultiply(DECT0);

            // Flowchart 5.1 - Create resource consumption pattern matrix
            this.res_cons_pat = GenResConsPat( ip );

            // Flowchart 5.2 - Compute TRU
            // Calculate vector of total units of resource
            // consumption, by product
            ColumnVector TRU = this.CalcResConsumption( QT );

            // Flowchart 5.3 - Compute MAXRU
            // Calculate resource consumption under the assumption
            // that all products are produced at maximum quantity
            ColumnVector MAXRU = this.CalcResConsumption( mxq );

            RowVector RCC, PC_B, RCCN;
            double TCT0;

            #region Flowchart 5.4 - Generate RCC, RCU, and RCCN

            /* -------------------------------- */
            // Flowchart 5.4(a)-(g)

            // Generate vector of total resource costs (RCC)
            RCC = GenRCC( ip );

            /* -------------------------------- */
            // Flowchart 5.4(h)

            // Now generate unit resource costs (RCU) by doing element-wise
            // division of RCC by MAXRU
            this.rcu = RCC.Map((x, i) => x / MAXRU[i]);

            /* -------------------------------- */
            // Flowchart 5.4(i)

            // Compute new RCC vector (RCCN) based on unit resource
            // costs (RCU) and true unit resource consumption (TRU)
            RCCN = this.rcu.ewMultiply(TRU);
            // Check to see if the first resource (RCCN[0]) is the largest.
            // If not, increase RCU[0] by just enough to make it so.
            if (RCCN[0] < RCCN.Skip(1).Max() + 1) {
                RCCN[0] = Math.Ceiling(RCCN.Max()) + 1.0;
                this.rcu[0] = RCCN[0] / TRU[0];
            }

            #endregion

            // Flowchart 5.5 - Calculate PC_B
            // Calculate true unit product costs
            PC_B = this.CalcTrueProductCosts();

            // Flowchart 5.6 - Compute total costs TCT0
            // Compute total costs
            TCT0 = this.CalcTotCosts(QT);

            // Flowchart 5.7 - Rename RCCN to RCC
            RCC = RCCN;
            initial_rcc = RCC;

            #region Flowchart 5.8 - Calculate SP, TRV0, PROFITT0

            // Calculate product selling prices, total revenue, and profit
            this.sp = PC_B.ewMultiply(MAR);
            double TRV0 = this.sp * QT;
            this.profitt0 = TRV0 - TCT0;

            #endregion

            // 5.9(a) Create RANK vector
            // Note: this method provides a stable sort. It's important to use a stable sort.
            // LOOKUP IN VERSION.TXT WHY IT'S IMPORTANT TO USE A STABLE SORT HERE.
            initial_rank = Enumerable.Range(0, RCC.Dimension).OrderByDescending(i => RCC[i]).ToArray();

            #region Flowchart 5.9(b) - Create RES_CONS_PAT_PRCT

            this.res_cons_pat_prct = new RectangularMatrix(ip.RCP, ip.CO);

            for (int r = 0; r < this.res_cons_pat.RowCount; ++r) {
                RowVector rv = this.res_cons_pat.Row(r);
                if (TRU[r] != 0.0) {
                    rv = rv.Map((alt_ij, col) => alt_ij * QT[col] / TRU[r]);
                    if (Math.Abs(rv.Sum() - 1.0) > 0.01)
                        throw new ApplicationException("Sum of row of RES_CONS_PAT_PRCT not equal to 1.");
                }
                else
                    rv = rv.Map(alt_ij => 0.0);

                this.res_cons_pat_prct.CopyRowInto(rv, r);
            }

            #endregion

            #region Flowchart 5.9(c) - Create correlation matrix 
            // Create correlation matrix for rows of RES_CONS_PAT_PRCT
            MultivariateSample mvs = new MultivariateSample(ip.RCP);
            for (int c = 0; c < this.res_cons_pat_prct.ColumnCount; ++c)
                mvs.Add(this.res_cons_pat_prct.Column(c));

            this.pearsoncorr = new SymmetricMatrix(ip.RCP);

            for (int i = 0; i < mvs.Dimension; ++i)
                for (int j = i; j < mvs.Dimension; ++j) {
                    //PearsonCorr[i, j] = mvs.PearsonRTest( i, j ).Statistic;
                    this.pearsoncorr[i, j] = mvs.TwoColumns(i, j).PearsonRTest().Statistic;
                }

            #endregion

            // Flowchart 5.10 - Logging true system
            // Note: I'm deliberately passing copies of the fields MXQ, SP, etc.
            Output.LogFirm(
                ip, this, FirmID,
                MAR, DECT0,
                TRV0, TCT0, profitt0,
                RCC );
        }

        #region Helper functions for creating margins, MXQ, RCC, RES_CONS_PAT matrix

        /// <summary>
        /// Generates a resource consumption pattern matrix
        /// </summary>
        /// <param name="ip">The current InputParameters object</param>
        private RectangularMatrix GenResConsPat( InputParameters ip ) {
            bool throwAway;
            int numThrows = 0;

            RectangularMatrix outputMatrix;

            do {
                throwAway = false;
                outputMatrix = new RectangularMatrix(ip.RCP, ip.CO);

                // Flowchart 5.1(a): Generate vector X
                RowVector X = GenRandNumbers.GenStdNormalVec(ip.CO);

                // The following code is used in both 5.1(b) and 5.1(c):
                RowVector[] Y = new RowVector[ip.RCP - 1];
                RowVector[] Z = new RowVector[Y.Length];

                for (int i = 0; i < Y.Length; ++i)
                    Y[i] = GenRandNumbers.GenStdNormalVec(ip.CO);

                // Flowchart 5.1(b): Generate (DISP1 - 1) vectors Y
                // Then create Z vectors based on X and Y
                double COR1 =
                    GenRandNumbers.GenUniformDbl(ip.COR1LB, ip.COR1UB);
                double sqrtConstant1 = Math.Sqrt(1 - COR1 * COR1);
                for (int i = 0; i < ip.DISP1 - 1; ++i)
                    Z[i] = (COR1 * X) + (sqrtConstant1 * Y[i]);

                // Flowchart 5.1(c): Generate (RCP - DISP1) vectors Y
                // Then create the remaining Z vectors based on X and Y
                double COR2 =
                    GenRandNumbers.GenUniformDbl(ip.COR2LB, ip.COR2UB);
                double sqrtConstant2 = Math.Sqrt(1 - COR2 * COR2);
                for (int i = ip.DISP1 - 1; i < Z.Length; ++i)
                    Z[i] = (COR2 * X) + (sqrtConstant2 * Y[i]);

                // Flowchart 5.1(d): 
                // Take the absolute values of X and the Z's and
                // scale both by 10.0.
                X = X.Map(x => 10.0 * Math.Abs(x));
                for (int i = 0; i < Z.Length; ++i)
                    Z[i] = Z[i].Map(z => 10.0 * Math.Abs(z));

                // Round X and the Z's to integers
                X = X.Map(x => Math.Ceiling(x));
                for (int i = 0; i < Z.Length; ++i)
                    Z[i] = Z[i].Map(z => Math.Ceiling(z));

                // Flowchart 5.1(e): 
                // Now punch out values in the Z's at random to make
                // the matrix sparse
                for (int i = 0; i < Z.Length; ++i)
                    Z[i] = Z[i].Map(x => ((GenRandNumbers.GenUniformDbl() < D) ? x : 0.0));

                // Flowchart 5.1(f): 
                // Copy X into first row of outputMatrix.
                outputMatrix.CopyRowInto(X, 0);
                // Copy the Z's into the remaining rows of outputMatrix.
                for (int i = 0; i < Z.Length; ++i)
                    outputMatrix.CopyRowInto(Z[i], i + 1);

                // Ensure that the first row has no zeros
                // There is a very small probability of getting a zero with
                // the Ceiling function, but given that there are a finite
                // number of double-precision floating point numbers, it
                // is not impossible to get a 0.0.
                double[] firstRow = outputMatrix.Row(0).ToArray();

                if (Array.Exists(firstRow, x => x == 0.0)) {
                    throwAway = true;
                    break;
                }

                // Ensure that each *row* has at least one non-zero entry
                for (int i = 0; i < outputMatrix.RowCount; ++i) {
                    double[] nextRow = outputMatrix.Row(i).ToArray();

                    if (Array.TrueForAll(nextRow, x => x == 0.0)) {
                        throwAway = true;
                        break;
                    }
                }

                // Ensure that each *column* has at least one non-zero entry
                // Technically, this check is redundant, as the first row, X,
                // is not supposed to have any zero entries. But just to be
                // on the safe side...
                for (int j = 0; j < outputMatrix.ColumnCount; ++j) {
                    double[] nextCol = outputMatrix.Column(j).ToArray();

                    if (Array.TrueForAll(nextCol, x => x == 0.0)) {
                        string s = "There is a column with all zeros. " +
                            "That should not happen since the first row is " +
                            "supposed to have no zeros.";
                        throw new ApplicationException(s);
                    }
                }

                if (throwAway) ++numThrows;
            } while (throwAway);

            Console.WriteLine("RES_CONS_PAT: {0} Throw aways\n", numThrows);

            return outputMatrix;
        }

        /// <summary>
        /// Generates a vector of product margins. Each element is
        /// U[ip.MARLB, ip.MARUB]. Values less than (greater) than one indicate
        /// products that generate losses (profits).
        /// </summary>
        /// <param name="ip">The current InputParameters object</param>
        /// <returns>A [1 x CO] vector, each element drawn from
        /// the distribution U[ip.MARLB, ip.MARUB].</returns>
        private RowVector GenMargins(InputParameters ip) {
            return new RowVector(ip.CO)
                       .Map(x => GenRandNumbers.GenUniformDbl(ip.MARLB, ip.MARUB));
        }

        /// <summary>
        /// Generates a random vector of capacities (maximum production
        /// quantities). Each element is drawn from discrete U[10,40].
        /// </summary>
        /// <param name="ip">The current InputParameters object</param>
        /// <returns>A [CO x 1] vector, each element drawn from
        /// the *discrete* distribution U[10,40].</returns>
        private ColumnVector GenMXQ(InputParameters ip) {
            return new ColumnVector(ip.CO).Map(x => GenRandNumbers.GenUniformInt(10, 40));
        }

        /// <summary>
        /// Implements step 5.3 of the flowchart: Generates a [1 x RCP] vector of
        /// total resource costs by resource.
        /// </summary>
        /// <param name="ip">An input parameters object.</param>
        private RowVector GenRCC( InputParameters ip ) 
        {
            bool throwAway;
            int numThrows = 0;
            List<double> rcc;

            // repeat the following loop until a suitable vector
            // RCC is generated.
            do {
                /* -------------------------------- */
                // Flowchart 5.4(b)

                // Calculate total resource cost of first DISP1 resources
                double topTR = G * ip.TR;
                // Calculate minimum allowable resource cost in first
                // DISP1 resources
                double rmin = (1.0 - G) * ip.TR / (ip.RCP - ip.DISP1);
                // The following is an upward adjustment of rmin.
                // Without this, the values of the resources in the
                // remaining resources have too little variance.
                // It checks how much room there is to adjust rmin,
                // and takes 2.5% of that room. The 2.5% was determined
                // through trial and error.
                double maxValOfLargestElem = topTR - ((ip.DISP1 - 1.0) * rmin);
                rmin += (maxValOfLargestElem - rmin) * 0.025;

                /* -------------------------------- */
                // Flowchart 5.4(c)

                // Generate the first DISP1 random numbers
                List<double> temp1 = new List<double>();
                for (int i = 1; i <= ip.DISP1 - 1; ++i) {
                    double rmax = (topTR - temp1.Sum()) - ((ip.DISP1 - i) * rmin);
                    if (rmax < rmin)
                        throw new ApplicationException("rmax less than rmin");
                    double ri = GenRandNumbers.GenUniformDbl(rmin, rmax);
                    temp1.Add(ri);
                }
                // The final element is computed to ensure that the total
                // in temp1 is topTR
                temp1.Add(topTR - temp1.Sum());
                // Move the biggest resource to the front
                double temp1Max = temp1.Max();
                if (!temp1.Remove(temp1Max))
                    throw new ApplicationException("Could not remove largest element.");
                temp1.Insert(0, temp1Max);

                // SOME CHECKS ON THE NUMBERS
                if (Math.Abs(temp1.Sum() - ip.TR * G) > 1.0)
                    throw new ApplicationException("Sum of first DISP1 resources not correct.");
                if (temp1.Min() < (1 - G) * ip.TR / (ip.RCP - ip.DISP1))
                    throw new ApplicationException("Min element too small.");

                /* -------------------------------- */
                // Flowchart 5.4(d)

                List<double> temp2 = new List<double>();
                for (int i = 0; i < ip.RCP - ip.DISP1; ++i) {
                    temp2.Add(GenRandNumbers.GenUniformDbl(0.05, 0.95));
                }
                temp2.Normalize();
                temp2.MultiplyBy((1.0 - G) * ip.TR);

                double temp1Min = temp1.Min();
                while (temp2.Max() - temp1.Min() > 1.0) {
                    // Sort the list in descending order
                    temp2.Sort();
                    temp2.Reverse();

                    for (int i = 0; i < temp2.Count / 2; ++i) {
                        double overage = Math.Max(temp2[i] - temp1Min, 0.0);
                        temp2[i] -= overage;
                        temp2[temp2.Count - 1 - i] += overage;
                    }
                }
                temp2.Shuffle();

                // SOME CHECKS
                if (Math.Abs(temp2.Sum() - ip.TR * (1.0 - G)) > 1.0)
                    throw new ApplicationException("Sum of small resources not correct.");

                /* -------------------------------- */
                // Flowchart 5.4(e)
                rcc = new List<double>(ip.RCP);
                rcc.AddRange(temp1);
                rcc.AddRange(temp2);

                /* -------------------------------- */
                // Flowchart 5.4(f)
                throwAway = rcc.Exists(x => x < 1.0);

                // SOME CHECKS
                if (rcc.Min() < 0.0)
                    throw new ApplicationException("Negative element in RCC.");

                if (throwAway) ++numThrows;
            } while (throwAway);

            return new RowVector(rcc);
        }

        #endregion

        #endregion

        #region Methods

        /// <summary>
        /// Returns a vector (TRU) containing the total consumption (number
        /// of units) of each resource, given production quantities q.
        /// </summary>
        /// <param name="q">A vector containing production quantities.</param>
        /// <returns>Returns an [ip.RCP x 1] vector, in which each element
        /// contains the number of units consumed of that resource.</returns>
        public ColumnVector CalcResConsumption(ColumnVector q) {
            return res_cons_pat * q;
        }

        /// <summary>
        /// Given *unit* resource costs RCU and a production mix q,
        /// returns the total cost (TCT) of producing q. 
        /// </summary>
        /// <param name="q">A [ip.CO x 1] vector of production quantities.</param>
        /// <returns>The total cost of producing q: (RCU * res_cons_pat * q)</returns>
        public double CalcTotCosts(ColumnVector q) {
            return rcu * res_cons_pat * q;
        }

        /// <summary>
        /// Given *unit* resource costs rcu, computes true, benchmark product costs (PC_B).
        /// </summary>
        /// <returns>A [1 x CO] vector of true unit product costs 
        /// (RCU * RES_CONS_PAT)</returns>
        public RowVector CalcTrueProductCosts() {
            return rcu * res_cons_pat;
        }

        /// <summary>
        /// Computes the profit-maximizing decision (DECT0), given true costs and selling prices.
        /// </summary>
        /// <returns>A [1 x ip.CO] vector of 1's and 0's. 1.0 (0.0) indicates 
        /// that the product is (not)included in the profit-maximizing product mix.</returns>
        public RowVector CalcOptimalDecision() {
            RowVector pc_b = CalcTrueProductCosts();
            RowVector productProfits = this.sp - pc_b;
            // Replace each negative (nonnegative) element of productProfits with a 0.0 (1.0)
            var dect0 = productProfits.Map(x => ((x < 0.0) ? 0.0 : 1.0));

            return new RowVector(dect0);
        }

        /// <summary>
        /// Computes the profit-maximizing production quantities (QT), given true costs and selling prices.
        /// </summary>
        /// <returns>A [ip.CO x 1] vector of production quantities.</returns>
        public ColumnVector CalcOptimalVol() {
            RowVector dect0 = CalcOptimalDecision();

            if (mxq.Dimension != dect0.Dimension)
                throw new ApplicationException("MXQ and DECT0 have different lengths.");

            var qt = mxq.Zip(dect0, (maxq, decision) => maxq * decision);
            return new ColumnVector(qt.ToArray());
        }

        #endregion

        #region Properties

        /// <summary>
        /// Element ij of the matrix is the number of units of resource i (row) 
        /// consumed by product j (column).
        /// Dimensions: ip.RCP x ip.CO
        /// Returns a copy and will cause a speed penalty if you make frequent calls.
        /// Make a local copy if necessary.
        /// </summary>
        public RectangularMatrix RES_CONS_PAT {
            get { return res_cons_pat.Copy(); }
        }

        /// <summary>
        /// Percentage of each resource consumed by each product. Each row will sum to 1.0.
        /// Dimensions: ip.RCP x ip.CO
        /// Returns a copy and will cause a speed penalty if you make frequent calls.
        /// Make a local copy if necessary.
        /// </summary>
        public RectangularMatrix RES_CONS_PAT_PRCT {
            get { return res_cons_pat_prct.Copy(); }
        }

        /// <summary>
        /// Correlation matrix showing correlations of resource consumptions.
        /// Dimensions: ip.RCP x ip.RCP
        /// Returns a copy and will cause a speed penalty if you make frequent calls.
        /// Make a local copy if necessary.
        /// </summary>
        public SymmetricMatrix PEARSONCORR {
            get { return pearsoncorr.Copy(); }
        }

        /// <summary>
        /// A vector of maximum production quantities of the products (cost objects).
        /// Dimensions: ip.CO x 1
        /// Returns a copy and will cause a speed penalty if you make frequent calls.
        /// Make a local copy if necessary.
        /// </summary>
        public ColumnVector MXQ {
            get { return mxq.Copy(); }
        }

        /// <summary>
        /// Vector of unit resource costs (price the firm pays per unit of each resource).
        /// Dimensions: 1 x ip.RCP
        /// Returns a copy and will cause a speed penalty if you make frequent calls.
        /// Make a local copy if necessary.
        /// </summary>
        public RowVector RCU {
            get { return rcu.Copy(); }
        }

        /// <summary>
        /// Vector of selling prices of products (cost objects).
        /// Dimensions: 1 x ip.CO
        /// Returns a copy and will cause a speed penalty if you make frequent calls.
        /// Make a local copy if necessary.
        /// </summary>
        public RowVector SP {
            get { return sp.Copy(); }
        }

        /// <summary>
        /// Randomly generated vector of resource costs (RCC) used to create this firm.
        /// Dimensions: 1 x ip.RCP
        /// Returns a copy and will cause a speed penalty if you make frequent calls.
        /// Make a local copy if necessary.
        /// </summary>
        public RowVector Initial_RCC {
            get { return initial_rcc.Copy(); }
        }

        /// <summary>
        /// The ranking of resources, by size, in the initial RCC vector.
        /// Length: ip.RCP
        /// Returns a copy and will cause a speed penalty if you make frequent calls.
        /// Make a local copy if necessary.
        /// </summary>
        public int[] Initial_RANK {
            get {
                int len = initial_rank.Length;
                int[] copy = new int[len];
                Array.Copy(initial_rank, copy, len);

                return copy;
            }
        }

        /// <summary>
        /// The profit generated by producing the profit-maximizing product mix.
        /// </summary>
        public double PROFITT0 {
            get { return profitt0; }
        }

        /// <summary>
        /// The value of DISP2.
        /// </summary>
        public double G => g;

        /// <summary>
        /// The density (sparsity) of the RES_CONS_PAT matrix.
        /// </summary>
        public double D => d;

        #endregion
    }
}
